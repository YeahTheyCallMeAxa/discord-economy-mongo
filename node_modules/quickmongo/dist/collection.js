"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = void 0;
const dot_prop_1 = __importDefault(require("dot-prop"));
/**
 * The QuickMongo collection
 */
class Collection {
    /**
     * Create new quickmongo collection instance
     * @param {MongoCollection} collection The MongoDB collection
     * @param {FieldModel} model Field model
     * @example const mongo = await MongoClient.connect("mongodb://127.0.0.1:61582");
     * const mongoCollection = mongo.db("quickmongo").collection("test");
     * const schema = new QuickMongo.Fields.ObjectField({...});
     * const db = new QuickMongo.Collection(collection, schema);
     */
    constructor(collection, model) {
        this.collection = collection;
        this.model = model;
    }
    /**
     * Returns if the collection has data with the specified key.
     * <warn>This method only checks if the data is **NOT** undefined.</warn>
     * @param {string} key The key
     * @param {string} path The path
     * @returns {Promise<boolean>}
     */
    has(key, path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.get(key, path);
                return typeof data !== "undefined";
            }
            catch (_a) {
                return false;
            }
        });
    }
    get(key, path) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = (yield this.collection.findOne({
                ID: key
            })) || {};
            if (data) {
                this.model.validate(data);
                if (path) {
                    if (typeof data !== "object") {
                        throw new Error("Received value must be an 'object'");
                    }
                    return dot_prop_1.default.get(data, path);
                }
            }
            return data || undefined;
        });
    }
    set(key, value, path) {
        return __awaiter(this, void 0, void 0, function* () {
            const nVal = path ? yield this.get(key) : value;
            if (path && nVal) {
                if (typeof nVal !== "object") {
                    throw new Error("Received value must be an 'object'");
                }
                dot_prop_1.default.set(nVal, path, value);
            }
            this.model.validate(nVal);
            const data = yield this.collection.updateOne({
                ID: key
            }, {
                $set: {
                    data: nVal
                }
            }, {
                upsert: true
            });
            if (data.modifiedCount > 0 || data.upsertedCount > 0)
                return nVal;
        });
    }
    delete(key, path) {
        return __awaiter(this, void 0, void 0, function* () {
            let deleted = false;
            if (path) {
                const value = yield this.get(key);
                if (value) {
                    if (typeof value !== "object") {
                        throw new Error("Received value must be an 'object'");
                    }
                    dot_prop_1.default.set(value, path, null);
                    yield this.set(key, value);
                    deleted = true;
                }
            }
            else {
                const result = yield this.collection.deleteOne({
                    ID: key
                });
                deleted = result.deletedCount === 1;
            }
            return deleted;
        });
    }
    /**
     * Drops this collection
     * @returns {Promise<boolean>}
     */
    drop() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.collection.drop();
            }
            catch (_a) {
                return false;
            }
        });
    }
    /**
     * Returns all data from this collection as array
     * @param {AllCollectionDocumentOptions} [options={}] The options
     * @returns {Promise<FieldToDocumentScheme[]>}
     */
    all(options = {}) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.collection
                .find()
                .limit(options.max || 0)
                .sort((_a = options.sort) === null || _a === void 0 ? void 0 : _a.target, ((_b = options.sort) === null || _b === void 0 ? void 0 : _b.by) || undefined)
                .toArray();
            return data;
        });
    }
    /**
     * Pushes to the array inside a field
     * @param {string} key The key
     * @param {any|any[]} value The value to push
     * @param {string} path The path where it should push
     * @returns {Promise<FieldType|undefined>}
     */
    push(key, value, path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof value === "undefined")
                throw new Error("cannot push undefined");
            const data = yield this.get(key, path);
            if (!Array.isArray(data))
                throw new TypeError(`Cannot call push because target "${key}${path ? `.${path}` : ""}" is not array`);
            !Array.isArray(value) ? data.push(value) : data.push(...value);
            const rData = yield this.set(key, data, path);
            return rData;
        });
    }
    /**
     * Pulls from the array inside a field
     * @param {string} key The key
     * @param {any|any[]} value The value to pull
     * @param {string} path The path where it should push
     * @returns {Promise<FieldType|undefined>}
     */
    pull(key, value, path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof value === "undefined")
                throw new Error("cannot pull undefined");
            const data = yield this.get(key, path);
            if (!Array.isArray(data))
                throw new TypeError(`Cannot call pull because target "${key}${path ? `.${path}` : ""}" is not array`);
            const newData = !Array.isArray(value) ? data.filter((x) => x !== value) : data.filter((x) => !value.includes(x));
            const rData = yield this.set(key, newData, path);
            return rData;
        });
    }
    /**
     * Returns the db latency in ms
     * @returns {Promise<number>}
     */
    latency() {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            yield this.all({ max: 1 });
            return Date.now() - start;
        });
    }
    /**
     * Exports this collection to a json object
     * @returns {Promise<CollectionExport>}
     */
    export() {
        return __awaiter(this, void 0, void 0, function* () {
            const everything = yield this.all();
            return {
                db: this.collection.dbName,
                name: this.collection.collectionName,
                namespace: this.collection.namespace,
                data: everything.map((m) => ({ ID: m.ID, data: m.data })) // remove _id
            };
        });
    }
}
exports.Collection = Collection;
