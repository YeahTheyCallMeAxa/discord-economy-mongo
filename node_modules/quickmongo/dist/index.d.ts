import { SortDirection, Collection as Collection$1 } from 'mongodb';

/**
 * @extends FieldModel
 */
declare class AnyField extends FieldModel<any> {
    /**
     * Any field
     * @param {FieldModelOptions} [options] The Field Model Options
     */
    constructor(options?: FieldModelOptions<any>);
    /**
     * Validates the data
     * @returns {boolean}
     */
    validate(): true | never;
}

/**
 * @extends FieldModel
 */
declare class ArrayField<T extends FieldModel<unknown>> extends FieldModel<ArrayFieldType<T>> {
    model: T;
    /**
     * Array field
     * @param {FieldModelOptions} [options] The Field Model Options
     */
    constructor(model: T, options?: FieldModelOptions<ArrayFieldType<T>>);
    /**
     * Validates the data
     * @param {any} value The value to validate
     * @returns {boolean}
     */
    validate(value: unknown): true | never;
}
declare type ArrayFieldType<M extends FieldModel<unknown>> = M extends FieldModel<infer T> ? T[] : never;

/**
 * @extends FieldModel
 */
declare class BooleanField extends FieldModel<boolean> {
    /**
     * Boolean field
     * @param {FieldModelOptions} [options] The options
     */
    constructor(options?: FieldModelOptions<boolean>);
    /**
     * Validates the data
     * @param {any} value The value to validate
     * @returns {boolean}
     */
    validate(value: unknown): true | never;
}

/**
 * @extends FieldModel
 */
declare class NullableField<T extends FieldModel<unknown>> extends FieldModel<NullableFieldType<T>> {
    model: T;
    /**
     * The nullable field
     * @param {FieldModel} model the field model
     */
    constructor(model: T);
    /**
     * Validates the data
     * @param {any} value The value to validate
     * @returns {boolean}
     */
    validate(value: unknown): true | never;
}
declare type NullableFieldType<M extends FieldModel<unknown>> = M extends FieldModel<infer T> ? T | null | undefined : never;

/**
 * @extends FieldModel
 */
declare class NumberField extends FieldModel<number> {
    /**
     * The number field
     * @param {FieldModelOptions} [options] Field model options
     */
    constructor(options?: FieldModelOptions<number>);
    /**
     * Validates the data
     * @param {any} value The value to validate
     * @returns {boolean}
     */
    validate(value: unknown): true | never;
}

declare type ObjectFieldModel = {
    [s: string]: FieldModel<unknown>;
};
/**
 * @extends FieldModel
 */
declare class ObjectField<T extends ObjectFieldModel> extends FieldModel<ObjectFieldType<T>> {
    model: T;
    /**
     * The object field model
     * @param {FieldModel} model the model
     * @param {FieldModelOptions} [options] The field model options
     */
    constructor(model: T, options?: FieldModelOptions<ObjectFieldType<T>>);
    /**
     * Validates the data
     * @param {any} value The value to validate
     * @returns {boolean}
     */
    validate(value: unknown): true | never;
}
declare type ObjectFieldType<T extends ObjectFieldModel> = {
    [K in keyof T]: FieldType<T[K]>;
};

/**
 * @extends FieldModel
 */
declare class StringField extends FieldModel<string> {
    /**
     * The string field
     * @param {FieldModelOptions} [options] The field model options
     */
    constructor(options?: FieldModelOptions<string>);
    /**
     * Validates the data
     * @param {any} value The value to validate
     * @returns {boolean}
     */
    validate(value: unknown): true | never;
}

/**{
    db: string;
    name: string;
    namespace: string;
    data: {
        ID: string;
        data: FieldType<T>;
    }[];
} */
/**
 * @typedef {object} CollectionExport
 * @property {string} db The database name
 * @property {string} name The collection name
 * @property {string} namespace The collection namespace
 * @property {FieldToDocumentScheme[]} data The data
 */
/**
 * @typedef {object} AllCollectionDocumentOptions
 * @property {number} [max] The max value
 * @property {CollectionSortOptions} [sort={}] Sort options
 */
/**
 * @typedef {object} FieldToDocumentScheme
 * @property {string} ID The key
 * @property {FieldType} data The value
 */
/**
 * @typedef {object} CollectionSortOptions
 * @property {ascending|asc|descending|desc} [by] Sort direction
 * @property {string|string[]} [target] The sort target
 */
/**
 * @typedef {object} FieldModelOptions
 * @property {any} [defaultValue] The default value
 */
interface FieldModelOptions<T> {
    defaultValue?: T;
}
declare class FieldModel<T> {
    readonly options?: FieldModelOptions<T>;
    /**
     * The field model
     * @param {FieldModelOptions} [options] Field model options
     */
    constructor(options?: FieldModelOptions<T>);
    /**
     * Creates value
     * @param {any} value The value
     * @returns {any}
     */
    create(value: T): T;
    /**
     * Validates the data
     * @param {any} value The value to validate
     * @returns {boolean}
     */
    validate(value: unknown): true | never;
}
/**
 * The field type
 * @typedef {ArrayField|BooleanField|NullableField|NumberField|ObjectField|StringField} FieldType
 */
declare type FieldType<M extends FieldModel<unknown>> = M extends ArrayField<infer T> ? ArrayFieldType<T> : M extends BooleanField ? boolean : M extends NullableField<infer T> ? T | null | undefined : M extends NumberField ? number : M extends ObjectField<infer T> ? ObjectFieldType<T> : M extends StringField ? string : M extends AnyField ? any : never;

type index_d_FieldModelOptions<_0> = FieldModelOptions<_0>;
type index_d_FieldModel<_0> = FieldModel<_0>;
declare const index_d_FieldModel: typeof FieldModel;
type index_d_FieldType<_0> = FieldType<_0>;
type index_d_AnyField = AnyField;
declare const index_d_AnyField: typeof AnyField;
type index_d_ArrayField<_0> = ArrayField<_0>;
declare const index_d_ArrayField: typeof ArrayField;
type index_d_ArrayFieldType<_0> = ArrayFieldType<_0>;
type index_d_BooleanField = BooleanField;
declare const index_d_BooleanField: typeof BooleanField;
type index_d_NullableField<_0> = NullableField<_0>;
declare const index_d_NullableField: typeof NullableField;
type index_d_NullableFieldType<_0> = NullableFieldType<_0>;
type index_d_NumberField = NumberField;
declare const index_d_NumberField: typeof NumberField;
type index_d_ObjectFieldModel = ObjectFieldModel;
type index_d_ObjectField<_0> = ObjectField<_0>;
declare const index_d_ObjectField: typeof ObjectField;
type index_d_ObjectFieldType<_0> = ObjectFieldType<_0>;
type index_d_StringField = StringField;
declare const index_d_StringField: typeof StringField;
declare namespace index_d {
  export {
    index_d_FieldModelOptions as FieldModelOptions,
    index_d_FieldModel as FieldModel,
    index_d_FieldType as FieldType,
    index_d_AnyField as AnyField,
    index_d_ArrayField as ArrayField,
    index_d_ArrayFieldType as ArrayFieldType,
    index_d_BooleanField as BooleanField,
    index_d_NullableField as NullableField,
    index_d_NullableFieldType as NullableFieldType,
    index_d_NumberField as NumberField,
    index_d_ObjectFieldModel as ObjectFieldModel,
    index_d_ObjectField as ObjectField,
    index_d_ObjectFieldType as ObjectFieldType,
    index_d_StringField as StringField,
  };
}

declare type FieldToDocumentScheme<T extends FieldModel<unknown>> = {
    ID: string;
    data: FieldType<T>;
};
interface CollectionSortOptions {
    by?: SortDirection;
    target?: string | string[];
}
interface AllCollectionDocumentOptions {
    max?: number;
    sort?: CollectionSortOptions;
}
/**
 * The QuickMongo collection
 */
declare class Collection<T extends FieldModel<unknown>> {
    collection: Collection$1<FieldToDocumentScheme<T>>;
    model: T;
    /**
     * Create new quickmongo collection instance
     * @param {MongoCollection} collection The MongoDB collection
     * @param {FieldModel} model Field model
     * @example const mongo = await MongoClient.connect("mongodb://127.0.0.1:61582");
     * const mongoCollection = mongo.db("quickmongo").collection("test");
     * const schema = new QuickMongo.Fields.ObjectField({...});
     * const db = new QuickMongo.Collection(collection, schema);
     */
    constructor(collection: Collection$1<FieldToDocumentScheme<T>>, model: T);
    /**
     * Returns if the collection has data with the specified key.
     * <warn>This method only checks if the data is **NOT** undefined.</warn>
     * @param {string} key The key
     * @param {string} path The path
     * @returns {Promise<boolean>}
     */
    has(key: string, path?: string): Promise<boolean>;
    /**
     * Get data from the collection
     * @param {string} key The key to retrieve data
     * @param {string} [path] The path to pick from the data
     * @returns {Promise<FieldType|any>}
     */
    get(key: string): Promise<FieldType<T> | undefined>;
    get<P = unknown>(key: string, path: string): Promise<P | undefined>;
    /**
     * Set data to the collection
     * @param {string} key The key to retrieve data
     * @param {FieldType} value The data to save
     * @param {string} [path] The path to save data
     * @returns {Promise<FieldType>}
     */
    set(key: string, value: FieldType<T>): Promise<FieldType<T>>;
    set<P = unknown>(key: string, value: P, path: string): Promise<FieldType<T>>;
    /**
     * Delete a data from the collection
     * @param {string} key The key to remove
     * @param {string} [path] The path to remove
     * @returns {Promise<boolean>}
     */
    delete(key: string): Promise<boolean>;
    delete(key: string, path: string): Promise<boolean>;
    /**
     * Drops this collection
     * @returns {Promise<boolean>}
     */
    drop(): Promise<boolean>;
    /**
     * Returns all data from this collection as array
     * @param {AllCollectionDocumentOptions} [options={}] The options
     * @returns {Promise<FieldToDocumentScheme[]>}
     */
    all(options?: AllCollectionDocumentOptions): Promise<FieldToDocumentScheme<T>[]>;
    /**
     * Pushes to the array inside a field
     * @param {string} key The key
     * @param {any|any[]} value The value to push
     * @param {string} path The path where it should push
     * @returns {Promise<FieldType|undefined>}
     */
    push<P = unknown>(key: string, value: P, path?: string): Promise<FieldType<T> | undefined>;
    /**
     * Pulls from the array inside a field
     * @param {string} key The key
     * @param {any|any[]} value The value to pull
     * @param {string} path The path where it should push
     * @returns {Promise<FieldType|undefined>}
     */
    pull<P = unknown>(key: string, value: P, path?: string): Promise<FieldType<T> | undefined>;
    /**
     * Returns the db latency in ms
     * @returns {Promise<number>}
     */
    latency(): Promise<number>;
    /**
     * Exports this collection to a json object
     * @returns {Promise<CollectionExport>}
     */
    export(): Promise<{
        db: string;
        name: string;
        namespace: string;
        data: {
            ID: string;
            data: FieldType<T>;
        }[];
    }>;
}

declare const version: any;

export { AllCollectionDocumentOptions, Collection, CollectionSortOptions, FieldToDocumentScheme, index_d as Fields, version };
